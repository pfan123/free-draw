# 无限画布如何限流

> 当无限画布承载像“世界地图”这样海量的数据时，仅仅靠 Canvas 的基础渲染是不够的。我们需要从数据层、渲染层和资源层三个维度进行“限流”和优化。
> 我将为你整理一份针对超大规模无限画布的深度优化方案。

针对“世界地图”级别的超大规模无限画布，简单的渲染逻辑会迅速遇到瓶颈。要实现真正的“无限”且流畅，必须引入**空间索引、视口剔除和细节层次（LOD）**等深度优化技术。

以下是完整的深度优化方案：

### 1. 核心优化策略：从 O(N) 到 O(log N)

当你有 100 万个图形时，每一帧都遍历检查它们是否在屏幕内是不现实的。

| 技术手段                        | 解决的问题 | 实现原理                                                                                                         |
| :------------------------------ | :--------- | :--------------------------------------------------------------------------------------------------------------- |
| **空间索引 (Spatial Indexing)** | 查找效率   | 使用 **RBush (R-Tree)** 或 **Quadtree**。将图形按空间位置组织，查询视口内物体的时间复杂度从 O(N) 降至 O(log N)。 |
| **视口剔除 (Culling)**          | 渲染压力   | 只对空间索引返回的“可见物体”执行绘制命令。不在屏幕内的物体完全不参与计算。                                       |
| **细节层次 (LOD)**              | 视觉过载   | 根据缩放比例（Zoom）动态切换显示内容。缩小到全局时只看大轮廓，放大到局部时才显示文字和细节。                     |
| **瓦片化 (Tiling)**             | 内存瓶颈   | 将画布切分为 256x256 或 512x512 的瓦片。只加载当前视口附近的瓦片数据，实现按需加载。                             |

### 2. 深度限流方案

**数据限流 (Data Throttling)**

- **异步加载**：不要在平移时实时请求后端。设置一个 200ms 的 `debounce`，当用户停止滑动后再拉取当前区域的高精度数据。
- **预加载缓冲区**：实际查询的范围应比视口稍大（例如 1.2 倍），这样在微调位置时无需重新加载。

**渲染限流 (Render Throttling)**

- **离屏缓存 (Offscreen Canvas)**：将不经常变动的静态背景（如地图底图）预渲染到离屏 Canvas 瓦片中，主循环只需执行 `drawImage`，这是性能最高的渲染方式。
- **分帧处理**：如果一次性要初始化的对象太多，可以使用 `requestIdleCallback` 将任务拆分到多个空闲帧中完成。

### 3. 推荐的技术架构

1. **底层渲染**：建议使用 **WebGL** (PixiJS) 或 **WebGPU**。Canvas 2D 在处理超过 1 万个独立对象时会感到吃力。
2. **空间索引库**：推荐使用 [rbush](https://github.com/mourner/rbush)，它是目前 JavaScript 领域性能最强的空间索引库之一，支持批量插入。
3. **坐标系统**：使用**世界坐标系**存储所有数据，渲染时再通过变换矩阵转为**屏幕坐标系**。

### 4. 交付文件说明

- **`large_scale_canvas_optimization.md`**：详细的技术白皮书，涵盖了从理论到实践的完整优化路径。
- **`spatial_index_demo.js`**：核心逻辑演示，展示了如何使用 RBush 进行百万级数据的空间查询和 LOD 切换。

通过这套方案，你可以构建出一个像 Google Maps 或 Figma 一样流畅的超大规模无限画布系统。如果你需要针对某个特定库（如 Konva 或 PixiJS）的集成代码，请告诉我。
